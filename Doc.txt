Sudoku Solver Implementation Documentation

1. Approach (after some initial research from the web/wikipedia)

I will be using backtracking as the main algorithm for this project. Runtime may be slow compared to an approach that uses more reasoning and deduction,
but backtracking is simple to understand and implement, it guarantees a solution, and average runtime is better than brute force. Certain puzzles are 
slow, especially those with early 9's. 

Simply put, backtracking involves guessinga number in the first unanswered square, assuming its correct, and then trying to continue the solution from there.
If no solution exists with that guess, then we guess a different number. The easiest way to pick numbers is just to count from 1 to 9. This is why puzzles with
early 9s can be slow (we're checking thousands of possible solutions before correctly guessing 9). Maybe there's a way to mitigate this by randomly picking numbers
and keeping track of which have been guessed, but that's not really solving the problem: we can still get unlucky with the solution and our random guesses. I'd 
rather be bad at a certain, known set of puzzles than an unknown set at runtime.

2. Requirements for solution

Based on Overview.docx, here is a list of requirements to be fulfilled:

1. No sudoku libraries. (this requirement is met by implenting backtracking in python by myself)
2. The solution must be able to read puzzles from plain text. 
    Plain text files will have 9 rows each with 9 characters: 1-9 or X for empty square
3. The solution must write the solved puzzles to plain text files in the specified format with the name {0}.sln.txt {0} being the name of the input file 
4. The application should fail gracefully if it cannot solve a puzzle 
5. Adherance to best practices

3. Overview of solution

A command line interface that prompts for names of files containing puzzles. If the file is not in the correct format, ask again.
The CLI can give the user an option to quit at any time. When the program recieves a valid file name, it creates and solves the puzzle.
It can print the solution as well as write to file. Arguments can also be handed over to the program when run.

Basically the python program will have to do 3 things
1. Read a file with an unsolved sudoku puzzle
2. Solve the puzzle
3. Write the solved puzzle back to a file

From this list I can pick out 2 entities that would be part of this solution. Tasks relegated to reading and writing from files could belong to one class. 
Something like SudokuIO. It would be useful to have a class representing a sudoku puzzle instance. What are the properties (in this specific context) of a game?
I'd say that the original file name is worth having around. It could use a 2D array to store the puzzle. A SudokuGame should have behavior that allows it to check
for validity, check whether it is solved or not, and a function for printing.

File -> read by SudokuIO  -> creates a SudokuGame  -> solved by SudokuGame -> hands game to SudokuIO -> writes to new file

4. Unit Testing

5. Misc.
